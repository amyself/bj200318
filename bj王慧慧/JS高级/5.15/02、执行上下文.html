<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
<script type="text/javascript">
    //  到了这个位置    程序执行了 但是代码没有执行
//    程序执行   创建全局执行上下文环境（全局环境）
//    函数执行上下文（函数环境）

//  先找自身 发现没有   再找到fn 发现也没有  最后找到全局?  x
//   先找自身 发现没有   沿着作用域链找上级是否存在这个变量
//    fn1 > fn >window
//    fn1 > window
//    断点    但是一般我们不用这种方法
//    在chrome调试工具里边  设置断点我们是比较常用
//    设置断点时   是不执行当前行的
//    第一个按钮是跳到下一个断点
//    第二个按钮  跳过函数定义
//    第三个按钮   一步一步走   遇到函数调用 会进入函数体  其实更切近于正常代码的运行轨迹
//    第四个按钮  跳出当前函数
//    第六个按钮   让断点暂时失效
//    debugger;
    var a = 10;
    var b = 20;
  function fn() {
      var a = 100;
      b = 200;
      var c = 300;
    function fn1() {
        var d = 400;
        console.log(d);
    }
    fn1();
  }
  fn();
  console.log(a,b,c)
//  程序执行  代码还没有执行的那一刹那   创建全局执行上下文
//   之前所谓的开辟空间  其实就是生成变量对象
//   生成变量对象(包括预先解析：薛哲观点)     修改this指向    确定作用域链
//    然后代码开始执行

    //    call stack 栈      anonymous 匿名
    //      scope   作用域链
//    全局执行上下文
//   1.生成变量对象    收集变量    做预解析（看不见过程）    2.确认this指向 （全局当中看不到）  3.确认作用域链
//  以上三步执行完  才会到代码执行
//    函数执行上下文
//  1.生成变量对象  收集变量  做预解析  2.确认this指向   3.确认作用域链
//    以上三步做完  才会执行函数中的代码

//    作用域链  是由变量对象组成 任何执行环境都有自己的作用域链 由不同的变量对象构成
//    内部函数没有引用外部的变量  作用域链就不会包含这个外部函数的变量对象
//    只有引用了外部的变量才会包含  那个外部函数的变量对象  所有作用域链的顶端都是全局

</script>
</body>
</html>